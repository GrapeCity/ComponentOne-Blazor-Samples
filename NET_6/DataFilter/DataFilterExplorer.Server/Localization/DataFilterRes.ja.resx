<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About" xml:space="preserve">
    <value>詳しくは</value>
    <comment>About</comment>
  </data>
  <data name="AutoApplyFilter" xml:space="preserve">
    <value>フィルターの自動適用</value>
    <comment>Auto apply filter</comment>
  </data>
  <data name="CarListDescription" xml:space="preserve">
    <value>このサンプルは、C1DataFilter コントロールを使用して C1FlexGrid コントロールをフィルタリングする方法を示します。</value>
    <comment>This sample demonstrates how to use C1DataFilter control to filter the C1FlexGrid control.</comment>
  </data>
  <data name="CarListTitle" xml:space="preserve">
    <value>車両リスト</value>
    <comment>Cars List</comment>
  </data>
  <data name="ConditionalFiltersDescription" xml:space="preserve">
    <value>複数の条件を受け入れる新しい条件付きフィルターと新しいフルテキストフィルターを使用してデモンストレーションします。</value>
  </data>
  <data name="ConditionalFiltersTitle" xml:space="preserve">
    <value>条件付きフィルター</value>
  </data>
  <data name="CustomFilterDescription" xml:space="preserve">
    <value>C1DataFilterコントロールを使用してカスタムフィルターを表示する方法を示します。
 ウィンドウには C1TreeView と C1DataFilter があります。
C1TreeView は、ItemTemplate を使用してデータを表示します。
C1DataFilter は、次のカスタムフィルターを使用します。
CustomFilter に基づく ColorFilter: 車の色を選択することを可能にします。
CustomFilter に基づ くModelFilter: 車のモデルを選択することを可能にします。
ChecklistFilter に基づく PriceFilter: 車の価格帯を選択できます。</value>
    <comment>Demonstrates using C1DataFilter control to show custom filters.
There is C1TreeView and C1DataFilter on the window.
The C1TreeView uses ItemTemplate to shows data.
The C1DataFilter uses next custom filters:
ColorFilter based on CustomFilter, allows to choose the color of the car;
ModelFilter based on CustomFilter, allows to choose the model of the car;
PriceFilter based on ChecklistFilter, allows to choose the price range of cars.</comment>
  </data>
  <data name="CustomFilterTitle" xml:space="preserve">
    <value>カスタムフィルター</value>
    <comment>Custom Filters</comment>
  </data>
  <data name="FilterSummaryDescription" xml:space="preserve">
    <value>このサンプルは、チェックリストフィルターに FilterSummary を使用する方法を示します。また、さまざまな集計式とフィルターサマリーのカスタム形式を使用する方法も示します。</value>
    <comment>This sample demonstrates how to use the FilterSummary for the Checklist filter. Also shows how to use different aggregate expressions and custom format of filter summaries.</comment>
  </data>
  <data name="FilterSummaryTitle" xml:space="preserve">
    <value>フィルターの概要</value>
    <comment>Filter Summary</comment>
  </data>
  <data name="VirtualSourceDescription" xml:space="preserve">
    <value>このサンプルは、仮想化されたソースで C1DataFilter を使用する方法を示します。</value>
    <comment>This sample demonstrate how C1DataFilter can be used with a virtualized source.</comment>
  </data>
  <data name="VirtualSourceTitle" xml:space="preserve">
    <value>仮想ソース</value>
    <comment>Virtual Source</comment>
  </data>
  <data name="VirtualSource_TextLoading" xml:space="preserve">
    <value>データの読み込み中...</value>
    <comment>Loading...</comment>
  </data>
</root>