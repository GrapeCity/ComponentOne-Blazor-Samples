<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About" xml:space="preserve">
    <value>About</value>
  </data>
  <data name="AccordionTreesDescription" xml:space="preserve">
    <value>Accordions are multi-pane panels that keep only one panel expanded at a time. They are commonly used for navigation. You can use the C1TreeView control to implement accordions. This sample creates an Accordion using the C1TreeView and CSS by customizing the header display.</value>
  </data>
  <data name="Accordion_Tree" xml:space="preserve">
    <value>Accordion Tree</value>
  </data>
  <data name="Adding" xml:space="preserve">
    <value>Adding</value>
  </data>
  <data name="Adding_BoundTree" xml:space="preserve">
    <value>Add Node for Bound TreeView</value>
  </data>
  <data name="Adding_FirstChild" xml:space="preserve">
    <value>First child</value>
  </data>
  <data name="Adding_LastChild" xml:space="preserve">
    <value>Last child</value>
  </data>
  <data name="Adding_UnBoundTree" xml:space="preserve">
    <value>Add Node for UnBound TreeView</value>
  </data>
  <data name="AddItemDescription" xml:space="preserve">
    <value>For Adding new item for C1TreeView, &lt;b&gt;ItemsSource must implement INotifyCollectionChanged&lt;/b&gt; to allow the control to get notified of the changes, then it will be reflected automatically in the control. &lt;br/&gt; In this sample, we use &lt;i&gt;ObservableCollection&amp;lt;T&amp;gt;&lt;/i&gt; which is a built-in implementation of a data collection that implements the INotifyCollectionChanged interface.</value>
  </data>
  <data name="Behavior" xml:space="preserve">
    <value>Behavior</value>
  </data>
  <data name="BehaviorDescription" xml:space="preserve">
    <value>The control provides several properties that customize its behavior.&lt;br/&gt;
&lt;b&gt;ShowLines:&lt;/b&gt; Gets or sets a value that indicates whether the connecting lines are visible.&lt;br/&gt;
&lt;b&gt;WholeWidthSelection:&lt;/b&gt; Gets or sets whether the selection item should take the whole width of the control or not.&lt;br/&gt;
&lt;b&gt;ExpandMode:&lt;/b&gt; Gets or sets a value indicating the allowed number of expanded C1TreeViewItems.&lt;br/&gt;
&lt;ul&gt;
	&lt;li&gt;ExpandMode.Single: Gets or sets a value that determines if sibling nodes should be collapsed when a node is expanded.&lt;/li&gt;
	&lt;li&gt;ExpandMode.Multiple: Several items may be expanded simultaneously.&lt;/li&gt;
&lt;/ul&gt;
&lt;b&gt;SelectionMode:&lt;/b&gt; Gets or sets the selection behavior for a C1TreeView.&lt;br/&gt;
&lt;ul&gt;
	&lt;li&gt;SelectionMode.None: The user can not select any item.&lt;/li&gt;
	&lt;li&gt;SelectionMode.Single: The user can select only one item at a time. &lt;/li&gt;
	&lt;li&gt;SelectionMode.Multiple: The user can select multiple items without holding down a modifier key.&lt;/li&gt;
	&lt;li&gt;SelectionMode.Extended: The user can select multiple consecutive items while holding down the corresponding modifier key.&lt;/li&gt;
&lt;/ul&gt;</value>
  </data>
  <data name="CleanAccordionDescription" xml:space="preserve">
    <value>This sample creates an Accordion from the C1TreeView control using CSS. It also uses the ItemTemplate to customize the appearance.</value>
  </data>
  <data name="Clean_Accordion" xml:space="preserve">
    <value>Clean Accordion</value>
  </data>
  <data name="DragDropBtwTreesDescription" xml:space="preserve">
    <value>You can also drag and drop nodes between different TreeView controls. To do this, add an event handler for the &lt;b&gt;OnDragOver&lt;/b&gt; event to configure the behavior.</value>
  </data>
  <data name="DragDropBtwTreesIndex" xml:space="preserve">
    <value>Drag and Drop Between Trees</value>
  </data>
  <data name="DragDropDescription" xml:space="preserve">
    <value>The TreeView control supports Drag and Drop behavior. To enable this, set the &lt;b&gt;AllowDragDrop&lt;/b&gt; property to &lt;b&gt;true&lt;/b&gt;. This sample allows users to drag nodes to different positions in the TreeView.</value>
  </data>
  <data name="DragDropIndex" xml:space="preserve">
    <value>Drag and Drop</value>
  </data>
  <data name="IconTemplateDescription" xml:space="preserve">
    <value>&lt;b&gt;ExpandedIconTemplate:&lt;/b&gt; Content template for tree item expanded icon.&lt;br/&gt;
&lt;b&gt;CollapsedIconTemplate:&lt;/b&gt; Content template for tree item collapsed icon.&lt;br/&gt;
&lt;b&gt;ExpandedIconStyle:&lt;/b&gt; Gets or sets the style applied to the expanded/collapsed icon.&lt;br/&gt;</value>
  </data>
  <data name="ItemTemplate_Description" xml:space="preserve">
    <value>You can customize your own view for C1TreeView item by defining in ItemTemplate tag.</value>
  </data>
  <data name="NavigationTo" xml:space="preserve">
    <value>Navigating to &lt;b&gt;** {0} **&lt;/b&gt;</value>
  </data>
  <data name="Navigation_Description" xml:space="preserve">
    <value>When selecting nodes or traversing the C1TreeView control with the mouse or arrow keys, the OnItemSelected event may be triggered. You can use this event to control navigation. This example uses the OnItemSelected to display the selected node.</value>
  </data>
  <data name="Node Borders" xml:space="preserve">
    <value>Node Borders</value>
  </data>
  <data name="NodeBordersDescription" xml:space="preserve">
    <value>Using CSS, this example adds a bottom border to the tree nodes in the C1TreeView.</value>
  </data>
  <data name="Nodes" xml:space="preserve">
    <value>Nodes</value>
  </data>
  <data name="Overview" xml:space="preserve">
    <value>Overview</value>
  </data>
  <data name="Ready" xml:space="preserve">
    <value>Ready</value>
  </data>
  <data name="Removing" xml:space="preserve">
    <value>Removing</value>
  </data>
  <data name="RemovingBtn" xml:space="preserve">
    <value>Remove selected item</value>
  </data>
  <data name="RemovingDescription" xml:space="preserve">
    <value>This sample demonstrates how to remove nodes from the C1TreeView</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Right to Left</value>
  </data>
  <data name="RTLDescription" xml:space="preserve">
    <value>The C1TreeView supports the element's content to flow from right to left. To do this, the IsRTL property is set "True"</value>
  </data>
  <data name="Searching" xml:space="preserve">
    <value>Searching</value>
  </data>
  <data name="SearchingDescription" xml:space="preserve">
    <value>The C1AutoComplete control provides a good way to implement a search box to be used with the C1TreeView. In this sample, we call GetAllItems API to get all TreeViewItems and use that as an itemsSource for searching through the C1TreeView.</value>
  </data>
  <data name="ShowCheckboxesDescription" xml:space="preserve">
    <value>The TreeNodes can be displayed with a Checkbox by setting the ShowCheckboxes property to true.
You can use the OnItemSelected to get or set the list of checked items.</value>
  </data>
  <data name="Styling" xml:space="preserve">
    <value>Styling</value>
  </data>
  <data name="StylingDescription" xml:space="preserve">
    <value>You can customize the appearance of the C1TreeView using CSS. This example changes the style of selected item and color of each TreeNode.</value>
  </data>
  <data name="UnBoundTree_Description" xml:space="preserve">
    <value>This sample shows to how to define Unbound C1TreeView</value>
  </data>
</root>